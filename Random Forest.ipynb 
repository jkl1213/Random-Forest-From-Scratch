{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**STAT 4609 Assignment 1**\n",
    "\n",
    "Name: Tang King Lok UID: 3035366805"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Part 1\n",
    "- Please compare Decision Tree method, and Random Forest for classification task. If necessary, please include references properly.\n",
    "\n",
    "- Please illustrate how you could implement random forest with the help of python class DecisionTree. You can write some pseudo code for better illustration.\n",
    "\n",
    "The random forest model is made of many decision trees, which make decisions collectively, as opposed to the decision tree method, which only relies on a single tree. Random forest trains a large number of decision trees independently, which results in many uncorrelated decision tree models. This can improve the accuracy score from a single decsion tree greatly as it prevents overfitting (which a single decision tree tends to do, resulting in lower testing accuracy). Unlike the single decision tree, random forest can also be used to get a 'distance matrix' of the observations as we can count how many trees classify any two observations into the same label, i.e. the more trees, the more similar these two observations are. This can be useful as we can then use the distance matrix to perform other statistical analysis, such as multidimensional scaling (MDS). In addition, random forest is a form of ensemble learning which uses bagging to prevent overfitting.\n",
    "\n",
    "\n",
    "\n",
    "We could implement random forest by making a random forest class, which has the hyperparameters such as number of variables in a tree and bootstrap data size. The random forest class will then have a fit method that can generate bootstrap indices and pass the indices one by one to another function called creat_tree. The create tree function will then construct a decision class as done in the tutorial. This decision class will hold the the index and variable selection and generate a decision tree based on the bootstrap. The tree is stored in a list object in python. We repeat this process n times by looping in the fit method of random forest. In the end we have n distinct decision trees in the forest.\n",
    "\n",
    "Finally, we predict new data by asking each decision tree to predict the label. We then make prediction based which label is the most popular among the trees."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Part 2\n",
    "- 1. Modify the decision tree\n",
    "- 2. Implement random forest from scratch\n",
    "- 3. Testing model on test data, report accuracy and visualise results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "#%matplotlib notebook\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "from IPython.core.debugger import set_trace\n",
    "np.random.seed(1234)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This part is the same as the tutorial where you implement a single decision tree from scratch:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [],
   "source": [
    "#GIVEN A NODE AND COST FUNCTION, IT LOOPS THROUGH ALL POSSIBLE SPLIT IN ALL FEATURES AND VALUES UNTIL \n",
    "#IT FINS THE BEST ONE\n",
    "#Define split function\n",
    "def greedy_test(node, cost_fn):\n",
    "    #initialize the best parameter values\n",
    "    best_cost = np.inf\n",
    "    best_feature, best_value = None, None\n",
    "    num_instances, num_features = node.data.shape\n",
    "    #sort the features to get the test value candidates by taking the average of consecutive sorted feature values \n",
    "    data_sorted = np.sort(node.data[node.data_indices],axis=0)\n",
    "    #all the \"cutting points\" between two sorted data points by averaging two consecutive data\n",
    "    test_candidates = (data_sorted[1:] + data_sorted[:-1]) / 2.\n",
    "    #print(\"node.data_indices:\",node.data_indices)\n",
    "    #print(\"data_sorted:\",data_sorted)\n",
    "    #print(\"data_sorted[:-1]:\",data_sorted[:-1])\n",
    "    #print(\"test_candidates:\",test_candidates)\n",
    "    for f in range(num_features):\n",
    "        #stores the data corresponding to the f-th feature\n",
    "        data_f = node.data[node.data_indices, f]\n",
    "        for test in test_candidates[:,f]:\n",
    "            #Split the indices using the test value of f-th feature\n",
    "            left_indices = node.data_indices[data_f <= test]\n",
    "            right_indices = node.data_indices[data_f > test]\n",
    "            \n",
    "            #we can't have a split where a child has zero element\n",
    "            #if this is true over all the test features and their test values  then the function returns the best cost as infinity\n",
    "            #the command 'continue' means the rest of statements are all rejected if either child has zero element\n",
    "            if len(left_indices) == 0 or len(right_indices) == 0:                \n",
    "                continue\n",
    "            #compute the left and right cost based on the current split                                                         \n",
    "            left_cost = cost_fn(node.labels[left_indices])\n",
    "            \n",
    "            right_cost = cost_fn(node.labels[right_indices])\n",
    "            num_left, num_right = left_indices.shape[0], right_indices.shape[0]\n",
    "            #get the combined cost using the weighted sum of left and right cost\n",
    "            cost = (num_left * left_cost + num_right * right_cost)/num_instances\n",
    "            #update only when a lower cost is encountered\n",
    "            if cost < best_cost:\n",
    "                best_cost = cost\n",
    "                best_feature = f\n",
    "                best_value = test\n",
    "    return best_cost, best_feature, best_value\n",
    "#Define cost function \n",
    "def cost_misclassification(labels):\n",
    "    counts = np.bincount(labels) \n",
    "    class_probs = counts / np.sum(counts)\n",
    "    #you could compress both the steps above by doing class_probs = np.bincount(labels) / len(labels)\n",
    "    return 1 - np.max(class_probs)\n",
    "#computes the gini index cost\n",
    "def cost_gini_index(labels):\n",
    "    class_probs = np.bincount(labels) / len(labels)\n",
    "    return 1 - np.sum(np.square(class_probs)) \n",
    "#Define a node \n",
    "class Node:\n",
    "    #data_indices = number of data points = data.shape[0] ; parent = None at the beginning \n",
    "    #(so if parent resutls in false)\n",
    "    def __init__(self, data_indices, parent):\n",
    "        self.data_indices = data_indices                    #stores the data indices which are in the region defined by this node\n",
    "        self.left = None                                    #stores the left child of the node \n",
    "        self.right = None                                   #stores the right child of the node\n",
    "        self.split_feature = None                           #the feature for split at this node\n",
    "        self.split_value = None                             #the value of the feature for split at this node\n",
    "        if parent:\n",
    "            self.depth = parent.depth + 1                   #obtain the dept of the node by adding one to dept of the parent \n",
    "            self.num_classes = parent.num_classes           #copies the num classes from the parent \n",
    "            self.data = parent.data                         #copies the data from the parent\n",
    "            self.labels = parent.labels                     #copies the labels from the parent\n",
    "            #returns the frequency array of labels, eg. 1,1,3\n",
    "            class_prob = np.bincount(self.labels[data_indices], minlength=self.num_classes) #this is counting frequency of different labels in the region defined by this node\n",
    "            #returns the probability array of labels, eg.0.2 0.2 0.6\n",
    "            self.class_prob = class_prob / np.sum(class_prob)  #stores the class probability for the node\n",
    "            #note that we'll use the class probabilites of the leaf nodes for making predictions after the tree is built\n",
    "\n",
    "            #Define a decision tree\n",
    "class DecisionTree:\n",
    "    \n",
    "    #determining hyperparameters\n",
    "    def __init__(self, idx, f_idx, num_classes=None, max_depth=3, cost_fn=cost_gini_index, min_leaf_instances=1):\n",
    "        self.max_depth = max_depth      #maximum dept for termination \n",
    "        #empty root at the beginning\n",
    "        self.root = None                #stores the root of the decision tree \n",
    "        self.cost_fn = cost_fn          #stores the cost function of the decision tree \n",
    "        self.num_classes = num_classes  #stores the total number of classes\n",
    "        self.min_leaf_instances = min_leaf_instances  #minimum number of instances in a leaf for termination\n",
    "        self.idx = idx\n",
    "        self.f_idx = f_idx\n",
    "    \n",
    "    def fit(self, data, labels):\n",
    "        pass                            #pass in python 3 means nothing happens and the method here is empty\n",
    "    \n",
    "    def predict(self, data_test):\n",
    "        pass\n",
    "\n",
    "def fit(self, data, labels):\n",
    "    self.data = data\n",
    "    self.labels = labels\n",
    "    if self.num_classes is None:\n",
    "        self.num_classes = np.max(labels) + 1\n",
    "    #below are initialization of the root of the decision tree \n",
    "    #(setting up the node object for the root)\n",
    "    self.root = Node(np.arange(data.shape[0]), None)\n",
    "    #since the 'if parent' will be false at the beginning due to None argument above\n",
    "    #we have to set up data and labels ourselves at the beginning\n",
    "    self.root.data = data\n",
    "    self.root.labels = labels\n",
    "    self.root.num_classes = self.num_classes\n",
    "    self.root.depth = 0\n",
    "    #to recursively build the rest of the tree\n",
    "    self._fit_tree(self.root)\n",
    "    return self\n",
    "def _fit_tree(self, node):\n",
    "    \n",
    "    #this gives condition for stopping loop later on\n",
    "    #check that we do not terminate the tree development due to max depth requirement\n",
    "    #This gives the condition for termination of the recursion resulting in a leaf node\n",
    "    if node.depth == self.max_depth or len(node.data_indices) <= self.min_leaf_instances:\n",
    "        return\n",
    "    \n",
    "    #greedily select the best test by minimizing the cost\n",
    "    cost, split_feature, split_value = greedy_test(node, self.cost_fn)\n",
    "    #if the cost returned is infinity it means that it is not possible to split the node and hence terminate\n",
    "    if np.isinf(cost):\n",
    "        return\n",
    "    #print(f'best feature: {split_feature}, value {split_value}, cost {cost}')\n",
    "    #to get a boolean array confirming data indices corresponding to this node are in the left of the split\n",
    "    test = node.data[node.data_indices,split_feature] <= split_value\n",
    "    #store the split feature and value of the node\n",
    "    node.split_feature = split_feature\n",
    "    node.split_value = split_value\n",
    "    #define new nodes which are going to be the left and right child of the present node\n",
    "    left = Node(node.data_indices[test], node)\n",
    "    right = Node(node.data_indices[np.logical_not(test)], node)\n",
    "\n",
    "    #recursive call to the _fit_tree()\n",
    "    #the loop will stop when the condition in the first line above is reached\n",
    "    self._fit_tree(left)\n",
    "    self._fit_tree(right)\n",
    "    #assign the left and right child to present child (node.left is also a node)\n",
    "    node.left = left\n",
    "    node.right = right\n",
    "\n",
    "DecisionTree.fit = fit\n",
    "DecisionTree._fit_tree = _fit_tree\n",
    "\n",
    "def predict(self, data_test):\n",
    "    class_probs = np.zeros((data_test.shape[0], self.num_classes))\n",
    "    for n, x in enumerate(data_test):\n",
    "        node = self.root\n",
    "        #loop along the depth of the tree looking region where the present data sample fall in based on the split feature and value\n",
    "        while node.left:\n",
    "            #print(\"x: \",x)\n",
    "            #print(\"node.split_feature: \",node.split_feature)\n",
    "            #print(\"node.split_value: \",node.split_value)\n",
    "            if x[node.split_feature] <= node.split_value:\n",
    "                node = node.left\n",
    "            else:\n",
    "                node = node.right\n",
    "        #the loop terminates when you reach a leaf of the tree and the class probability of that node is taken for prediction\n",
    "        class_probs[n,:] = node.class_prob\n",
    "    return class_probs\n",
    "\n",
    "DecisionTree.predict = predict\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, we add the extra functionalities that random forest requires. \n",
    "1. We write a function to get bootstrapped data given randomly generated index and m random variables \n",
    "2. We write a random forest class. Its fit method generates all the indices and then calls the __create_tree__ function one at a time to create a single decision tree. The process is repeated until we have enough trees. All the trees are stored in a list object.\n",
    "3. The prediction is made by fitting testing data X to all the trees that we created. The trees will 'vote' for their predicted labels. We choose the label that most trees voted for.\n",
    "4. We design an accuracy function that can count how many testing data we predicted correctly to get a percentage for correct predictions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Define a function to get a bootstrapped sample given a bootstrapped index and a variable array\n",
    "def get_bts(x,y,idx,f_idx):\n",
    "        \n",
    "    #get a bootstrap sample index given data\n",
    "    #data = np.array([[1,2,1],[3,4,3],[5,6,5],[9,0,7]])\n",
    "    #y = np.array([[1],[0],[0],[2]])\n",
    "    data = x\n",
    "    y = y\n",
    "    m = len(y)\n",
    "    subdata = data[idx[0],f_idx].reshape(1,m)\n",
    "    suby = y[idx[0]].reshape(1,1)\n",
    "\n",
    "    for i in idx[1:]:\n",
    "        newdata = data[i,f_idx].reshape(1,m)\n",
    "        newy = y[i].reshape(1,1)\n",
    "        suby = np.concatenate((suby, newy))\n",
    "        subdata = np.concatenate((subdata, newdata))\n",
    "\n",
    "    #get the bootstrapped data with m variables in a dataframe\n",
    "    subdata_df = pd.DataFrame(subdata, columns=f_idx, index = idx)\n",
    "\n",
    "    #subdata array for the fit function\n",
    "    subdata_array_x = subdata\n",
    "    subdata_array_x\n",
    "    #subdata label array for the fit function\n",
    "    subdata_array_y = suby\n",
    "    #print(\"subdata_array_x:\",subdata_array_x)\n",
    "    #print(\"subdata_array_y:\",subdata_array_y)\n",
    "    return subdata_array_x,subdata_array_y\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Define a random forest \n",
    "class RandomForest():\n",
    "    def __init__(self, depth=10, min_leaf=5, n_trees = 8, n_features='log2', sample_sz = 20, cost_fn =cost_misclassification):\n",
    "        np.random.seed(12)\n",
    "        self.depth, self.min_leaf = depth, min_leaf \n",
    "        self.n_trees = n_trees \n",
    "        self.sample_sz, self.n_features =  sample_sz, n_features\n",
    "        self.cost_fn = cost_fn\n",
    "        self.forest = []\n",
    "        self.total_idx = None\n",
    "        self.total_f_idx = None\n",
    "        self.m = None\n",
    "    def get_bts(self,x,y,idx,f_idx):\n",
    "        \n",
    "        #get a bootstrap sample index given data\n",
    "        #data = np.array([[1,2,1],[3,4,3],[5,6,5],[9,0,7]])\n",
    "        #y = np.array([[1],[0],[0],[2]])\n",
    "        data = x\n",
    "        y = y\n",
    "        \n",
    "        subdata = data[idx[0],f_idx].reshape(1,self.m)\n",
    "        suby = y[idx[0]].reshape(1,1)\n",
    "\n",
    "        for i in idx[1:]:\n",
    "            newdata = data[i,f_idx].reshape(1,self.m)\n",
    "            newy = y[i].reshape(1,1)\n",
    "            suby = np.concatenate((suby, newy))\n",
    "            subdata = np.concatenate((subdata, newdata))\n",
    "\n",
    "        #get the bootstrapped data with m variables in a dataframe\n",
    "        subdata_df = pd.DataFrame(subdata, columns=f_idx, index = idx)\n",
    "\n",
    "        #subdata array for the fit function\n",
    "        subdata_array_x = subdata\n",
    "        subdata_array_x\n",
    "        #subdata label array for the fit function\n",
    "        subdata_array_y = suby\n",
    "        #print(\"subdata_array_x:\",subdata_array_x)\n",
    "        #print(\"subdata_array_y:\",subdata_array_y)\n",
    "        \n",
    "        return subdata_array_x,subdata_array_y\n",
    "\n",
    "    def fit(self, x, y):\n",
    "        #---------- fit training data with the help of function __create_tree__ -----# \n",
    "        #step 1: generate 8 bootstraps by sampling with replacement original data index\n",
    "        total_idx = []\n",
    "        total_f_idx = []\n",
    "        self.x = x\n",
    "        self.y = y\n",
    "        #for each bt, we fit a decision tree to the subdata\n",
    "        for i in range(self.n_trees):\n",
    "            \n",
    "            #generate bts\n",
    "            idx = np.random.choice(np.arange(len(x)),self.sample_sz,replace=True)\n",
    "            total_features = x.shape[1]\n",
    "            if self.n_features == 'log2':\n",
    "                self.m = round(np.log(total_features)/np.log(2))\n",
    "            elif self.n_features == 'sqrt':\n",
    "                self.m = round(np.sqrt(total_features))\n",
    "            \n",
    "            f_idx = np.random.choice(np.arange(x.shape[1]),round(self.m),replace=False)\n",
    "            total_idx.append(idx)\n",
    "            total_f_idx.append(f_idx)\n",
    "            \n",
    "            #fit a decision tree given generated index and m variables to bts\n",
    "            #print(\"total_idx[i]\",total_idx[i])\n",
    "            #print(\"total_f_idx[i]\",total_f_idx[i])\n",
    "            tree = self.__create_tree__(total_idx[i],total_f_idx[i])\n",
    "            self.forest.append(tree)\n",
    "            \n",
    "            self.total_idx = total_idx\n",
    "            self.total_f_idx = total_f_idx\n",
    "        \n",
    "        # --- implete step 1 -------#\n",
    "        pass\n",
    "    \n",
    "    def __create_tree__(self,idx,f_idx):\n",
    "        #---------- create and return one decision tree ---------------------#\n",
    "        #---  implete (a) and (b) of step 1 in random forest the algorithm in this python method ---- # \n",
    "        #(a)\n",
    "        subx, subyy = self.get_bts(self.x,self.y,idx,f_idx)\n",
    "        suby = subyy.reshape(-1,)\n",
    "        #print(\"subx\",subx)\n",
    "        #print(\"suby\",suby)\n",
    "        #Fitting data to decision tree with added idx and f_idx argument\n",
    "        model = DecisionTree(idx,f_idx,max_depth=20)\n",
    "        decision_tree = model.fit(subx,suby)\n",
    "        return decision_tree\n",
    "        #t = decision_tree.fit(subx, suby)\n",
    "        \n",
    "        \n",
    "        # self.trees = [...]\n",
    "        \n",
    "        # return DecisionTree(...)\n",
    "         \n",
    "        \n",
    "    def predict(self, x):\n",
    "        #---------- return the predicted probability for test data ----------#\n",
    "        \n",
    "        votes = []\n",
    "        for j in range(x.shape[0]):\n",
    "            data = x[j,:]\n",
    "            #print(data)\n",
    "            vote = np.zeros(3)\n",
    "            for i in range(self.n_trees):\n",
    "                #print(self.total_f_idx[i])\n",
    "                features = self.total_f_idx[i]\n",
    "                t = self.forest[i]\n",
    "               \n",
    "                processed_x = data[features].reshape(1,-1)\n",
    "                #print(\"processed_x:\",processed_x)\n",
    "                #print(\"pred:\", t.predict(processed_x))\n",
    "                pred = t.predict(processed_x)\n",
    "                vote = np.sum([vote, pred], axis=0)\n",
    "            \n",
    "            #the results for all test data is in votes eg. array([8,0,0],[7,1,0]) \n",
    "            #for two test data\n",
    "            votes.append(vote)\n",
    "            \n",
    "        return votes "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Part 3 experiments and visualization\n",
    "- Finally, we test out model on the iris dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn import datasets\n",
    "dataset = datasets.load_iris()\n",
    "x, y = dataset['data'][:,:], dataset['target']\n",
    "(num_instances, num_features), num_classes = x.shape, np.max(y)+1\n",
    "inds = np.random.permutation(num_instances)\n",
    "#train-test split)\n",
    "x_train, y_train = x[inds[:100]], y[inds[:100]]\n",
    "x_test, y_test = x[inds[100:]], y[inds[100:]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "rf = RandomForest()\n",
    "model = rf.fit(x_train,y_train)\n",
    "results = rf.predict(x_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {},
   "outputs": [],
   "source": [
    "#define a function to get the accuracy scores\n",
    "def get_accuracy(results,answer):\n",
    "    #results is a list of votes eg. [[8,0,0],[2,4,6]] answer is array of labels [1,0,0,1,2]\n",
    "    answer = y_test\n",
    "    right = 0\n",
    "    wrong = 0\n",
    "    record = np.zeros(len(results))\n",
    "    y_pred = np.zeros(len(results))\n",
    "    for i in range(len(results)):\n",
    "        #the predicted label is the one with the highest vote\n",
    "        if np.argmax(results[i][0]) == y_test[i]:\n",
    "            right = right + 1\n",
    "            record[i] = 1\n",
    "            y_pred[i] = np.argmax(results[i][0])\n",
    "        else:\n",
    "            wrong = wrong + 1\n",
    "        \n",
    "    #print(right/(right+wrong))\n",
    "    #print(\"y_pred:\",y_pred)\n",
    "    accuracy = right/(right+wrong)\n",
    "    return accuracy, record, y_pred"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The percentage for correct predictions is:  96 %\n"
     ]
    }
   ],
   "source": [
    "#Get the percentage of correct guesses in the testing set\n",
    "print(\"The percentage for correct predictions is: \", round(get_accuracy(results,y_test)[0]*100),\"%\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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xQl6jvXR09pHOBIiHAkSjgTpOtpNX/vAdJt23vKVJw6y+bG9nFiYKKVk82N7+coTB6c0bktLCytXruS2225j7dq1vOtd72LLli1s2rSJ5cuX88ILL/D973+fj33sYwD87Gc/Y+3atVx00UW85jWvAewA4Pbbb+fCCy9k3bp1fO1rXxt3nI985CNs3LiRNWvW8PnPf77w/Gc/+1lWr17NunXruP322096jBNRdU9PD+9+97vZuXMn69evp7m5uehO4He/+x1XXHEFGzZs4JZbbiGRSAC2nszKlSu58sorC8Jj5aCkCF0I0QjcANwF/O8JdnkLcMfw44eArwshhJyuZaiKOUXn0R5CVYFC9CeEIFDhp+toD7ULlOb6uUZKSTyT53vPtgDwuRtXs/mxvXzv2Rbet2nxlCP1w4cP87Of/Yz77ruPV73qVfzoRz/imWee4dFHH+ULX/gCN998c2HfzZs389vf/paGhgai0SgA9913H0ePHmXHjh04HI6CVsto7rrrLqqqqjBNk6uvvppdu3bR2NjIL37xC/bv348QojDeRMc4QW1tLffffz/33HMPjz32WNG2vr4+7rzzTrZs2YLf7+dLX/oSX/7yl/nMZz7DBz7wAZ566imWLVtW1oi+1Aj9q8BnAOsk2xuAVgAppQHEgHFKPUKIDwohtgkhtvX29p6BuYrzDSkllmmi6cUfVU3XMA3V5m46EELwuRtX875Ni/nesy00/cOvC878czeunnLapampiQsvvBBN01izZg1XX301QgguvPBCWlpaivbdtGkTt956K9/+9rcLbQ+3bNnChz/8YRwOO16dSB73pz/9KRs2bODiiy9mz5497N27l1AohMfj4bbbbuPhhx8uyOtOdIxSeO6559i7dy+bNm1i/fr1PPDAAxw7doz9+/fT1NTE8uXLEULw7ne/+wyv1HhO69CFEDcCPVLK7afabYLnxkXnUsr7pJQbpZQbIxFVD604PUIIquorSUSTRc8nYylqGuaOjvVs44RTH005nDmA2+0uPNY0rfC3pmnjWst961vf4s4776S1tZX169fT399/2juEo0ePcs899/Dkk0+ya9cubrjhBjKZDA6HgxdeeIG3ve1tBRGvkx2jFKSUvPGNb2Tnzp3s3LmTvXv38p3vfAc4e1VnpUTom4CbhBAtwI+B1wsh/mvMPm3AAgAhhAMI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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "#visualization\n",
    "y_pred = get_accuracy(results,y_test)[2]\n",
    "correct = np.array(get_accuracy(results,y_test)[1],dtype=bool)\n",
    "incorrect = np.logical_not(correct)\n",
    "plt.scatter(x_train[:,0], x_train[:,1], c=y_train, marker='o', alpha=.2, label='train')\n",
    "plt.scatter(x_test[correct,0], x_test[correct,1], marker='.', c=y_pred[correct], label='correct')\n",
    "plt.scatter(x_test[incorrect,0], x_test[incorrect,1], marker='x', c=y_test[incorrect], label='misclassified')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
